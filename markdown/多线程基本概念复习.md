### 多线程基本概念复习

### 基本概念：程序、进程、线程

* <span style="color:blue;font-size:20px;">**程序（program）**</span>是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。
* <span style="color:blue;font-size:20px;">**进程（process）**</span>是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程。———生命周期

> 如：运行中的QQ，运行中的MP3播放器
> 程序是静态的，进程是动态的
>
> 进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域

* <span style="color:blue;font-size:20px;">**线程（thread）**</span>，进程可进一步细化为线程，是一个程序内部的一条执行路径。

  > 若一个进程同一时间==并行==执行多个线程，就是支持多线程
  >
  > <span style="color:red">线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器（pc）</span>，线程切换的开销小
  >
  > 一个进程中的多个线程共享相同的内存单元/内存地址空间〉它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来<span style="color:red">安全的隐患</span>。

* **单核CPU和多核CPU的理解**

> 1. 单核CPU，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。例如：虽然有多车道，但是收费站只有一个工作人员在收费，只有收了费才能通过，那么PU就好比收费人员。如果有某个人不想交钱，那么收费人员可以把他“挂起”（晾着他，等他想通了，准备好了钱，再去收费）。但是因为CPU时间单元特别短，因此感觉不出来。
>    如果是多核的话，才能更好的发挥多线程的效率。（现在的服务器都是多核的）
> 2. 一个Java应用程序`java.exe`，其实至少有三个线程：`main（）`主线程，`gc（）`垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。

* **并行与并发**

  > **并行**：多个CPU同时执行多个任务。比如：多个人同时做不同的事。
  > **并发**：一个CPU（采用时间片）同时执行多个任务。比如：秒杀、多个人做同一件事。

### 使用多线程的优点

**背景：**以单核CPU为例，只使用单个线程先后完成多个任务（调用多个方法），肯定比用多个线程来完成用的时间更短，为何仍需多线程呢？
==多线程程序的优点：==

    		1. 提高应用程序的响应。对图形化界面更有意义，可增强用户体验。
    		2. 提高计算机系统CPU的利用率
    		3. 改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改



### 线程的创建和启动

* Java语言的JVM允许程序运行多个线程，它通过`java.lang.Thread`类来体现。

**Thread类的特性**

每个线程都是通过某个特定`Thread对象`的`run()方法`来完成操作的，经常把`run()方法`的主体称为线程体
通过该`Thread对象`的`start()方法`来启动这个线程，而<span style="color:red">非直接调用run()</span>



### 创建多线程的两种方法

#### 方式一：继承Thread类的方式

```java
/*
 *
 * 多线程的创建，方式一：继承与Thread类
 * 1.创建一个继承于Thread类的子类
 * 2.重写Thread类的run()
 * 3.创建Thread类的子类的对象
 * 4.通过此对象调用start()
 *
 *
 * 例子：遍历100以内的所有的偶数
 */
//1.创建一个继承于Thread类的子类
class myThread extends Thread{
    //2.重写Thread类的run()
    @Override
    public void run(){
        for (int i = 0; i < 100; i++) {
            if(i % 2 == 0){
                System.out.println(Thread.currentThread().getName()+" : "+i);
            }
        }
    }
}
public class ThreadTest {
    public static void main(String[] args) {
//        3.创建Thread类的子类的对象
        myThread test = new myThread(); //ALT+ENTER 快捷声明
//        4.通过此对象调用start()：①启动当前线程 ②调用当前线程的run()
        test.start();
//        test.run();  //直接调用run是在main中执行，只是执行了对象调方法，没有开启多线程
//        我们不能通过直接调run()的方式启动线程。
//       再启动一个线程，遍历100以内的偶数，不可以还让已经start()的线程去执行，会报IllegalThreadStateExpection
//        test.start();
        myThread test2 = new myThread();
        test2.start();
        // 如下操作仍然是在main线程中执行的
        for (int i = 0; i < 100; i++) {
            if(i % 2 == 0){
                System.out.println(Thread.currentThread().getName()+" : "+i+"***********main****************");
            }
        }


    }
}
```

#### 方式二：继承Thread类的方式

```java
/**
 * 创建多线程的方式二：实现Runnable接口
 *  1.创建一个实现了Runnanle接口的类
 *  2.实现类去实现Runnable中的抽象方法，run()
 *  3.创建实现类的对象
 *  4.将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象
 *  5.通过Thread类的对象调用start()
 *
 *  比较创建线程的两种方式：
 *      开发中：优先选择，实现Runnable接口的方式
 *      原因：1.实现的方式没有类的单继承性的局限性
 *           2.实现的方式更适合来处理多个线程有共享数据的情况
 *      二者联系：public class Thread implements Runable
 *      相同点：两种方式都需要重写run()，将线程要执行的逻辑声明在run()中
 */
public class ThreadTest1 {
    public static void main(String[] args) {
        // 3.创建实现类的对象
        RThread rThread = new RThread();
        // 4.将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象
        Thread t1 = new Thread(rThread);
        // 5.通过Thread类的对象调用start()
        t1.setName("线程一");
        t1.start();

        // 在开一个线程
        Thread t2 = new Thread(rThread);
        t2.setName("线程二");
        t2.start();


    }
}
//1.创建一个实现了Runnanle接口的类
class RThread implements Runnable{

    // 2.实现类去实现Runnable中的抽象方法，run()
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            if(i % 2 == 0){
                System.out.println(Thread.currentThread().getName()+":"+i);
            }
        }
    }

}
```

#### 创建Thread类的匿名子类的方式

```java
        //创建Thread类的匿名子类的方式
        new Thread(){
            @Override
            public void run() {
                for (int i = 0; i < 100; i++) {
                    if(i % 2 == 0)
                        System.out.println(Thread.currentThread().getName()+" : "+i);
                }
            }
        }.start();

        new Thread(){
            @Override
            public void run() {
                for (int i = 0; i < 100; i++) {
                    if( i % 2 != 0 ){
                        System.out.println(Thread.currentThread().getName()+" : "+i);
                    }
                }
            }
        }.start();
```

#### Thread常用方法及优先级

```java
/**
 * 测试Thread中的常用方法：
 *  1.start():启动当前线程，调用当前线程的run()
 *  2.run():通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中
 *  3.currentThread():静态方法，返回执行当前代码的线程
 *  4.getName():获取当前线程的名字
 *  5.setName():设置当前线程的名字
 *  6.yield():释放当前cpu的执行权
 *  7.join():在线程a中调用线程b的join()，此时线程a就进入阻塞状态，直到线程b完全执行结束，
 *          线程a才结束阻塞状态。
 *  8.stop():已经过时。当前执行此方法时，强制结束当前线程。
 *  9.sleep(long millitime):让当前线程“睡眠”指定的millistime毫秒。在指定的时间内，
 *                          当前线程是阻塞状态。
 *  10.isAlive():判断当前线程是否存活
 *
 *  线程的优先级：
 *  1.
 *  MAX_PRIORITY:10
 *  MIN_PRIORITY:1
 *  NORM_PRIORITY:5  -->默认优先级
 *  2.如何获取和设置当前线程的优先级：
 *      getPriority():获取线程的优先级
 *      setPriority(int p):设置线程的优先级
 *
 *      说明：高优先级的线程要抢占低优先级线程cpu的执行权，但是只是从概率上讲，高优先级的线程高概率的情况下
 *      被执行。并不意味只有当高优先级线程执行完后，低优先级线程才执行。
 *
 *
 *  alt+7 打开结构图，查看方法、构造器
 *  ctrl+ Fn + F12 打开弹窗的形式查看当前类的方法、构造器
 *  ctrl+ h 查看类的继承关系
 *  另一个方式：光标放在需要查看的类上 ctrl+alt+u，可以图像的形式查看继承关系
 * */
class HelloThread extends Thread{
    @Override
    public void run() { // Thread 没有throws，所以子类重写也不能throws
        for (int i = 0; i < 100; i++) {
            if(i % 2 == 0){
                try {
//                    Thread.sleep(1000);  //单位是ms(毫秒)
                    sleep(10); //省略Thread
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName()+" : "+
                        Thread.currentThread().getPriority()+" : "+i);
            }
//            if(i % 20 == 0){
//                this.yield();
//            }
        }
    }
    // 命名方式二：
    public HelloThread(String name){
        super(name);
    }
}
public class ThreadMethod {
    public static void main(String[] args) {
        HelloThread helloThread = new HelloThread("Thread:1");
//        helloThread.setName("线程一"); // 命名方式一
        //设置分线程的优先级
        helloThread.setPriority(Thread.MAX_PRIORITY); // 设置为MAX_PRORITY,(10)

        helloThread.start();

        // 给主线程命名
        Thread.currentThread().setName("主线程");
        // 设置主线程的优先级
        Thread.currentThread().setPriority(Thread.MIN_PRIORITY); //给主线程设置为最小
        for (int i = 0; i < 100; i++) {
            if(i % 2 == 0){
                System.out.println(Thread.currentThread().getName()+" : "+
                        Thread.currentThread().getPriority()+" : "+i);
            }
            //join()方法
            if(i == 20){
                try {
                    helloThread.join();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }

        }
        System.out.println(helloThread.isAlive()); // 不存活：返回false
    }
}
```





